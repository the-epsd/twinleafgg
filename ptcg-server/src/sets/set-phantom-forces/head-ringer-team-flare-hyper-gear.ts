// This file was auto-generated by the card stub generator.
// Card effects were implemented by an agent.
// If you have any questions or feedback, reach out to @C4 in the discord.

import { TrainerCard } from '../../game/store/card/trainer-card';
import { CardTag, CardType, TrainerType } from '../../game/store/card/card-types';
import { GameError, GameMessage, PlayerType, SlotType, StoreLike, State, StateUtils } from '../../game';
import { Effect } from '../../game/store/effects/effect';
import { CheckAttackCostEffect } from '../../game/store/effects/check-effects';
import { PlayItemEffect } from '../../game/store/effects/play-card-effects';
import { ChoosePokemonPrompt } from '../../game/store/prompts/choose-pokemon-prompt';
import { IS_TOOL_BLOCKED } from '../../game/store/prefabs/prefabs';

export class HeadRingerTeamFlareHyperGear extends TrainerCard {
  public trainerType: TrainerType = TrainerType.ITEM;
  public set: string = 'PHF';
  public setNumber: string = '97';
  public cardImage: string = 'assets/cardback.png';
  public name: string = 'Head Ringer Team Flare Hyper Gear';
  public fullName: string = 'Head Ringer Team Flare Hyper Gear PHF';
  public text: string = 'Attach this Pokemon Tool to 1 of your opponent\'s Pokemon-EX that doesn\'t already have a Pokemon Tool attached to it. The attacks of the Pokémon this card is attached to cost [C][C] more. When this card is removed from a Pokémon for any reason, put this card in its owner\'s discard pile.';

  // Refs: set-furious-fists/politoed.ts (CheckAttackCostEffect), set-stellar-crown/gravity-gemstone.ts (tool cost modification)
  public reduceEffect(store: StoreLike, state: State, effect: Effect): State {
    // Handle playing this card from hand - attach to opponent's Pokemon-EX
    if (effect instanceof PlayItemEffect && effect.trainerCard === this) {
      const player = effect.player;
      const opponent = StateUtils.getOpponent(state, player);

      // Check if opponent has any Pokemon-EX without a tool
      let hasValidTarget = false;
      opponent.forEachPokemon(PlayerType.TOP_PLAYER, (cardList, card) => {
        if (card.tags.includes(CardTag.POKEMON_EX) && cardList.tools.length === 0) {
          hasValidTarget = true;
        }
      });

      if (!hasValidTarget) {
        throw new GameError(GameMessage.CANNOT_PLAY_THIS_CARD);
      }

      // Prevent default item discard behavior
      effect.preventDefault = true;

      // Build blocked list using CardTarget format
      const blocked: { player: PlayerType, slot: SlotType, index: number }[] = [];
      const opponentActive = opponent.active;
      const opponentActivePokemon = opponentActive.getPokemonCard();

      if (!opponentActivePokemon || !opponentActivePokemon.tags.includes(CardTag.POKEMON_EX) || opponentActive.tools.length > 0) {
        blocked.push({ player: PlayerType.TOP_PLAYER, slot: SlotType.ACTIVE, index: 0 });
      }

      opponent.bench.forEach((benchSlot, index) => {
        const pokemonCard = benchSlot.getPokemonCard();
        if (!pokemonCard || !pokemonCard.tags.includes(CardTag.POKEMON_EX) || benchSlot.tools.length > 0) {
          blocked.push({ player: PlayerType.TOP_PLAYER, slot: SlotType.BENCH, index });
        }
      });

      return store.prompt(state, new ChoosePokemonPrompt(
        player.id,
        GameMessage.CHOOSE_POKEMON_TO_ATTACH_CARDS,
        PlayerType.TOP_PLAYER,
        [SlotType.ACTIVE, SlotType.BENCH],
        { min: 1, max: 1, allowCancel: false, blocked }
      ), targets => {
        if (targets && targets.length > 0) {
          const target = targets[0];
          player.hand.moveCardTo(this, target);
          target.tools.push(this);
        }
      });
    }

    // Add [C][C] to attack costs of the Pokemon this is attached to
    if (effect instanceof CheckAttackCostEffect) {
      const player = effect.player;

      // Check if this card is attached to the attacking Pokemon
      if (!player.active.tools.includes(this)) {
        return state;
      }

      if (IS_TOOL_BLOCKED(store, state, player, this)) {
        return state;
      }

      effect.cost.push(CardType.COLORLESS);
      effect.cost.push(CardType.COLORLESS);
    }

    return state;
  }
}
