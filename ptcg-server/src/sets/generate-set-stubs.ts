// @ts-nocheck
// Card Stub Generator: card-data.json → TypeScript stubs
// Usage: npx ts-node ptcg-server/src/sets/generate-set-stubs.ts <set-directory-name> [--dry-run] [--force]

const fs = require('fs');
const path = require('path');

const STUB_HEADER = '// This file was auto-generated by the card stub generator.\n// Card effects were implemented by an agent.\n// If you have any questions or feedback, reach out to @C4 in the discord.\n';

// ==================== TYPE MAPPINGS ====================

const TYPE_TO_SHORT: Record<string, string> = {
  'Grass': 'G', 'Fire': 'R', 'Water': 'W', 'Lightning': 'L', 'Psychic': 'P',
  'Fighting': 'F', 'Darkness': 'D', 'Dark': 'D', 'Metal': 'M', 'Colorless': 'C',
  'Fairy': 'Y', 'Dragon': 'N',
};

function typeShort(type: string): string {
  const short = TYPE_TO_SHORT[type];
  if (!short) {
    console.warn(`  WARNING: Unknown energy type '${type}', defaulting to C (Colorless)`);
    return 'C';
  }
  return short;
}

function getStage(subtypes: string[]): string {
  if (!subtypes) return 'Stage.BASIC';
  for (const st of subtypes) {
    switch (st) {
      case 'Basic': return 'Stage.BASIC';
      case 'Stage 1': return 'Stage.STAGE_1';
      case 'Stage 2': return 'Stage.STAGE_2';
      case 'Restored': return 'Stage.RESTORED';
      case 'MEGA': return 'Stage.MEGA';
      case 'VMAX': return 'Stage.VMAX';
      case 'VSTAR': return 'Stage.VSTAR';
      case 'BREAK': return 'Stage.BREAK';
      case 'Level-Up': return 'Stage.LV_X';
    }
  }
  return 'Stage.BASIC';
}

function getTags(subtypes: string[]): string[] {
  if (!subtypes) return [];
  const tags: string[] = [];
  for (const st of subtypes) {
    switch (st) {
      case 'EX': tags.push('CardTag.POKEMON_EX'); break;
      case 'ex': tags.push('CardTag.POKEMON_ex'); break;
      case 'V': tags.push('CardTag.POKEMON_V'); break;
      case 'VMAX': tags.push('CardTag.POKEMON_VMAX'); break;
      case 'VSTAR': tags.push('CardTag.POKEMON_VSTAR'); break;
      case 'GX': tags.push('CardTag.POKEMON_GX'); break;
      case 'TAG TEAM': tags.push('CardTag.TAG_TEAM'); break;
      case 'MEGA': tags.push('CardTag.MEGA'); break;
      case 'BREAK': tags.push('CardTag.BREAK'); break;
      case 'V-UNION': tags.push('CardTag.POKEMON_VUNION'); break;
      case 'Prism Star': tags.push('CardTag.PRISM_STAR'); break;
      case 'Ultra Beast': tags.push('CardTag.ULTRA_BEAST'); break;
      case 'Team Plasma': tags.push('CardTag.TEAM_PLASMA'); break;
      case 'Single Strike': tags.push('CardTag.SINGLE_STRIKE'); break;
      case 'Rapid Strike': tags.push('CardTag.RAPID_STRIKE'); break;
      case 'Fusion Strike': tags.push('CardTag.FUSION_STRIKE'); break;
    }
  }
  return tags;
}

function getTrainerType(subtypes: string[]): string {
  if (!subtypes || !subtypes.length) return 'TrainerType.ITEM';
  for (const st of subtypes) {
    switch (st) {
      case 'Item': return 'TrainerType.ITEM';
      case 'Supporter': return 'TrainerType.SUPPORTER';
      case 'Stadium': return 'TrainerType.STADIUM';
      case 'Pokémon Tool': return 'TrainerType.TOOL';
      case 'Technical Machine': return 'TrainerType.TOOL';
    }
  }
  return 'TrainerType.ITEM';
}

function getPowerType(type: string): string {
  switch (type) {
    case 'Ability': return 'PowerType.ABILITY';
    case 'Poké-Body': return 'PowerType.POKEBODY';
    case 'Poké-Power': return 'PowerType.POKEPOWER';
    case 'Ancient Trait': return 'PowerType.ANCIENT_TRAIT';
    case 'Pokémon Power': return 'PowerType.POKEMON_POWER';
    default: return 'PowerType.ABILITY';
  }
}

function getUseWhenInPlay(type: string): boolean {
  switch (type) {
    case 'Poké-Body': return false;
    default: return true;
  }
}

const GENERIC_RULES = [
  'You may play as many Item cards as you like during your turn (before your attack).',
  'You can play only one Supporter card during your turn (before your attack).',
  'You can play only one Supporter card during your turn.',
  'Attach a Pokémon Tool to 1 of your Pokémon that doesn\'t already have a Pokémon Tool attached to it.',
  'Attach Pokémon Tool to 1 of your Pokémon that doesn\'t already have a Pokémon Tool attached to it.',
];

function filterGenericRules(rules: string[]): string[] {
  return rules.filter(r => {
    const trimmed = r.trim();
    if (trimmed.startsWith('This stadium stays in play') || trimmed.startsWith('This Stadium stays in play')) return false;
    if (trimmed.startsWith('This card stays in play when you play it')) return false;
    return !GENERIC_RULES.some(g => trimmed === g);
  });
}

// ==================== UTILITY FUNCTIONS ====================

function toPascalCase(str: string): string {
  return str
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .replace(/♀/g, 'F').replace(/♂/g, 'M')
    .replace(/&/g, ' And ')
    .replace(/'/g, '')
    .split(/[^a-zA-Z0-9]+/)
    .filter(Boolean)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

function toKebabCase(str: string): string {
  return str
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .replace(/♀/g, '-f').replace(/♂/g, '-m')
    .replace(/&/g, '-and-')
    .replace(/[^a-zA-Z0-9 -]/g, '')
    .trim()
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-');
}

function escapeSingleQuotes(str: string): string {
  return (str || '')
    .replace(/\\/g, '\\\\')
    .replace(/'/g, '\\\'')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r');
}

function convertEnergyNames(text: string): string {
  if (!text) return text;
  const ENERGY_NAME_TO_SYMBOL: Record<string, string> = {
    'Grass': '[G]', 'Fire': '[R]', 'Water': '[W]', 'Lightning': '[L]',
    'Psychic': '[P]', 'Fighting': '[F]', 'Darkness': '[D]', 'Dark': '[D]',
    'Metal': '[M]', 'Colorless': '[C]', 'Fairy': '[Y]', 'Dragon': '[N]',
  };
  for (const [name, symbol] of Object.entries(ENERGY_NAME_TO_SYMBOL)) {
    text = text.replace(new RegExp(name + ' Energy', 'g'), symbol + ' Energy');
  }
  return text;
}

function parseDamage(dmgStr: string): { damage: number; damageCalculation?: string } {
  if (!dmgStr || dmgStr.trim() === '') return { damage: 0 };
  const match = dmgStr.trim().match(/^(\d+)([+×x\-]?)$/);
  if (!match) return { damage: 0 };
  const damage = parseInt(match[1], 10);
  const mod = match[2];
  if (mod === '+') return { damage, damageCalculation: '+' };
  if (mod === '×' || mod === 'x') return { damage, damageCalculation: 'x' };
  if (mod === '-') return { damage, damageCalculation: '-' };
  return { damage };
}

function parseResistanceValue(value: string): number {
  if (!value) return -20;
  const match = value.match(/-?(\d+)/);
  return match ? -Math.abs(parseInt(match[1], 10)) : -20;
}

// ==================== CARD CLASSIFICATION ====================

function cardNeedsReduceEffect(card: any): boolean {
  if (card.supertype === 'Trainer') return true;
  if (card.supertype === 'Energy') return true;
  if (card.abilities && card.abilities.length > 0) return true;
  if (card.attacks) {
    for (const attack of card.attacks) {
      if (attack.text && attack.text.trim() !== '') return true;
    }
  }
  return false;
}

function cardsAreIdentical(a: any, b: any): boolean {
  if (a.name !== b.name) return false;
  const aAttacks = a.attacks || [];
  const bAttacks = b.attacks || [];
  if (aAttacks.length !== bAttacks.length) return false;
  for (let i = 0; i < aAttacks.length; i++) {
    if (aAttacks[i].name !== bAttacks[i].name) return false;
    if ((aAttacks[i].text || '') !== (bAttacks[i].text || '')) return false;
  }
  const aAbilities = a.abilities || [];
  const bAbilities = b.abilities || [];
  if (aAbilities.length !== bAbilities.length) return false;
  for (let i = 0; i < aAbilities.length; i++) {
    if (aAbilities[i].name !== bAbilities[i].name) return false;
    if ((aAbilities[i].text || '') !== (bAbilities[i].text || '')) return false;
  }
  return true;
}

// ==================== CROSS-SET INDEX ====================

interface CrossSetEntry {
  className: string;
  setDir: string;
  fileName: string;
  hasReduceEffect: boolean;
  attackNames: string[];
  abilityNames: string[];
}

function buildCrossSetIndex(setsDir: string, currentSetDir: string): Map<string, CrossSetEntry[]> {
  const index = new Map<string, CrossSetEntry[]>();

  let setDirs: string[];
  try {
    setDirs = fs.readdirSync(setsDir).filter((d: string) => {
      const fullPath = path.join(setsDir, d);
      return d.startsWith('set-') && d !== currentSetDir && fs.statSync(fullPath).isDirectory();
    });
  } catch {
    return index;
  }

  for (const setDir of setDirs) {
    const setPath = path.join(setsDir, setDir);
    let files: string[];
    try {
      files = fs.readdirSync(setPath).filter((f: string) =>
        f.endsWith('.ts') && f !== 'index.ts' && f !== 'other-prints.ts'
      );
    } catch {
      continue;
    }

    for (const file of files) {
      const filePath = path.join(setPath, file);
      let content: string;
      try {
        content = fs.readFileSync(filePath, 'utf-8');
      } catch {
        continue;
      }

      const classMatch = content.match(/export class (\w+)/);
      if (!classMatch) continue;

      const nameMatch = content.match(/public name[\s:]*(?:string\s*)?=\s*'((?:[^'\\]|\\.)*)'/);
      if (!nameMatch) continue;
      const cardName = nameMatch[1].replace(/\\'/g, '\'').replace(/\\\\/g, '\\');

      // Extract attack names from the attacks block
      const attackNames: string[] = [];
      const attacksBlock = content.match(/public attacks\s*=\s*\[([\s\S]*?)\n\s*\];/);
      if (attacksBlock) {
        for (const m of attacksBlock[1].matchAll(/name:\s*'((?:[^'\\]|\\.)*)'/g)) {
          attackNames.push(m[1].replace(/\\'/g, '\''));
        }
      }

      // Extract ability/power names from the powers block
      const abilityNames: string[] = [];
      const powersBlock = content.match(/public powers\s*=\s*\[([\s\S]*?)\n\s*\];/);
      if (powersBlock) {
        for (const m of powersBlock[1].matchAll(/name:\s*'((?:[^'\\]|\\.)*)'/g)) {
          abilityNames.push(m[1].replace(/\\'/g, '\''));
        }
      }

      const entries = index.get(cardName) || [];
      entries.push({
        className: classMatch[1],
        setDir,
        fileName: file.replace('.ts', ''),
        hasReduceEffect: content.includes('reduceEffect'),
        attackNames,
        abilityNames,
      });
      index.set(cardName, entries);
    }
  }

  return index;
}

// ==================== STUB GENERATION ====================

function generatePokemonStub(card: any, className: string, setCode: string, needsReduceEffect: boolean, fullName: string): string {
  const lines: string[] = [];
  lines.push(STUB_HEADER);
  const tags = getTags(card.subtypes);
  const hasAbilities = card.abilities && card.abilities.length > 0;
  const hasAttacksWithText = card.attacks?.some((a: any) => a.text && a.text.trim() !== '');

  // Imports
  const cardTypeImports = ['Stage', 'CardType'];
  if (tags.length) cardTypeImports.push('CardTag');

  lines.push('import { PokemonCard } from \'../../game/store/card/pokemon-card\';');
  lines.push(`import { ${cardTypeImports.join(', ')} } from '../../game/store/card/card-types';`);

  if (needsReduceEffect) {
    if (hasAbilities) {
      lines.push('import { PowerType, StoreLike, State } from \'../../game\';');
    } else {
      lines.push('import { StoreLike, State } from \'../../game\';');
    }
    lines.push('import { Effect } from \'../../game/store/effects/effect\';');

    const prefabs: string[] = [];
    if (hasAttacksWithText) prefabs.push('WAS_ATTACK_USED');
    if (hasAbilities) prefabs.push('WAS_POWER_USED');
    if (prefabs.length) {
      lines.push(`import { ${prefabs.join(', ')} } from '../../game/store/prefabs/prefabs';`);
    }
  }

  lines.push('');
  lines.push(`export class ${className} extends PokemonCard {`);

  // Tags
  if (tags.length) {
    lines.push(`  public tags = [${tags.join(', ')}];`);
  }

  // Stage
  lines.push(`  public stage: Stage = ${getStage(card.subtypes)};`);

  // evolvesFrom
  if (card.evolvesFrom) {
    lines.push(`  public evolvesFrom: string = '${escapeSingleQuotes(card.evolvesFrom)}';`);
  }

  // cardType
  const cardType = card.types && card.types[0] ? typeShort(card.types[0]) : 'C';
  lines.push(`  public cardType: CardType = ${cardType};`);

  // hp
  lines.push(`  public hp: number = ${parseInt(card.hp, 10) || 0};`);

  // weakness
  if (card.weaknesses && card.weaknesses.length > 0) {
    const ws = card.weaknesses.map((w: any) => `{ type: ${typeShort(w.type)} }`).join(', ');
    lines.push(`  public weakness = [${ws}];`);
  }

  // resistance
  if (card.resistances && card.resistances.length > 0) {
    const rs = card.resistances.map((r: any) => {
      return `{ type: ${typeShort(r.type)}, value: ${parseResistanceValue(r.value)} }`;
    }).join(', ');
    lines.push(`  public resistance = [${rs}];`);
  }

  // retreat
  const retreatArr = (card.retreatCost || []).map((t: string) => typeShort(t));
  lines.push(`  public retreat = [${retreatArr.join(', ')}];`);

  // powers
  if (hasAbilities) {
    lines.push('');
    const powerStrs = card.abilities.map((ab: any) => {
      return [
        '  {',
        `    name: '${escapeSingleQuotes(ab.name)}',`,
        `    useWhenInPlay: ${getUseWhenInPlay(ab.type)},`,
        `    powerType: ${getPowerType(ab.type)},`,
        `    text: '${escapeSingleQuotes(convertEnergyNames(ab.text || ''))}'`,
        '  }',
      ].join('\n');
    });
    if (powerStrs.length === 1) {
      lines.push(`  public powers = [${powerStrs[0]}];`);
    } else {
      lines.push(`  public powers = [\n${powerStrs.join(',\n')}\n  ];`);
    }
  }

  // attacks
  if (card.attacks && card.attacks.length > 0) {
    lines.push('');
    lines.push('  public attacks = [');
    const attackStrs = card.attacks.map((a: any) => {
      const cost = (a.cost || []).filter((c: string) => c !== 'Free').map((c: string) => typeShort(c));
      const { damage, damageCalculation } = parseDamage(a.damage);
      const text = escapeSingleQuotes(convertEnergyNames(a.text || ''));
      let s = `    {\n      name: '${escapeSingleQuotes(a.name)}',\n      cost: [${cost.join(', ')}],\n      damage: ${damage},`;
      if (damageCalculation) {
        s += `\n      damageCalculation: '${damageCalculation}' as '${damageCalculation}',`;
      }
      s += `\n      text: '${text}'\n    }`;
      return s;
    });
    lines.push(attackStrs.join(',\n'));
    lines.push('  ];');
  }

  // Set info
  lines.push('');
  if (card.regulationMark) {
    lines.push(`  public regulationMark: string = '${card.regulationMark}';`);
  }
  lines.push(`  public set: string = '${setCode}';`);
  lines.push(`  public setNumber: string = '${card.number}';`);
  lines.push('  public cardImage: string = \'assets/cardback.png\';');
  lines.push(`  public name: string = '${escapeSingleQuotes(card.name)}';`);
  lines.push(`  public fullName: string = '${escapeSingleQuotes(fullName)}';`);

  // reduceEffect
  if (needsReduceEffect) {
    lines.push('');
    lines.push('  public reduceEffect(store: StoreLike, state: State, effect: Effect): State {');

    let addedBlock = false;
    if (hasAbilities) {
      card.abilities.forEach((ab: any, idx: number) => {
        if (addedBlock) lines.push('');
        lines.push(`    // Ability: ${ab.name}`);
        lines.push(`    // TODO: ${convertEnergyNames(ab.text || 'Implement ability').replace(/\n/g, ' ')}`);
        lines.push(`    if (WAS_POWER_USED(effect, ${idx}, this)) {`);
        lines.push('      // Implement ability here');
        lines.push('    }');
        addedBlock = true;
      });
    }

    if (card.attacks) {
      card.attacks.forEach((a: any, idx: number) => {
        if (a.text && a.text.trim() !== '') {
          if (addedBlock) lines.push('');
          lines.push(`    // Attack ${idx + 1}: ${a.name}`);
          lines.push(`    // TODO: ${convertEnergyNames(a.text).replace(/\n/g, ' ')}`);
          lines.push(`    if (WAS_ATTACK_USED(effect, ${idx}, this)) {`);
          lines.push('      // Implement effect here');
          lines.push('    }');
          addedBlock = true;
        }
      });
    }

    lines.push('');
    lines.push('    return state;');
    lines.push('  }');
  }

  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

function generateTrainerStub(card: any, className: string, setCode: string, fullName: string): string {
  const lines: string[] = [];
  lines.push(STUB_HEADER);
  const tags = getTags(card.subtypes);

  lines.push('import { TrainerCard } from \'../../game/store/card/trainer-card\';');

  const cardTypeImports = ['TrainerType'];
  if (tags.length) cardTypeImports.push('CardTag');
  lines.push(`import { ${cardTypeImports.join(', ')} } from '../../game/store/card/card-types';`);

  lines.push('import { StoreLike, State } from \'../../game\';');
  lines.push('import { Effect } from \'../../game/store/effects/effect\';');
  lines.push('');
  lines.push(`export class ${className} extends TrainerCard {`);

  lines.push(`  public trainerType: TrainerType = ${getTrainerType(card.subtypes)};`);

  if (tags.length) {
    lines.push(`  public tags = [${tags.join(', ')}];`);
  }

  if (card.regulationMark) {
    lines.push(`  public regulationMark: string = '${card.regulationMark}';`);
  }
  lines.push(`  public set: string = '${setCode}';`);
  lines.push(`  public setNumber: string = '${card.number}';`);
  lines.push('  public cardImage: string = \'assets/cardback.png\';');
  lines.push(`  public name: string = '${escapeSingleQuotes(card.name)}';`);
  lines.push(`  public fullName: string = '${escapeSingleQuotes(fullName)}';`);

  const rules = card.rules || [];
  const meaningfulRules = filterGenericRules(rules).map(convertEnergyNames);
  if (meaningfulRules.length > 0) {
    const text = escapeSingleQuotes(meaningfulRules.join(' '));
    lines.push(`  public text: string = '${text}';`);
  }

  lines.push('');
  lines.push('  public reduceEffect(store: StoreLike, state: State, effect: Effect): State {');
  lines.push('    // TODO: Implement trainer effect');
  if (meaningfulRules.length > 0) {
    for (const rule of meaningfulRules) {
      lines.push(`    // ${rule.replace(/\n/g, ' ')}`);
    }
  }
  lines.push('');
  lines.push('    return state;');
  lines.push('  }');

  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

function generateEnergyStub(card: any, className: string, setCode: string, fullName: string): string {
  const lines: string[] = [];
  lines.push(STUB_HEADER);

  lines.push('import { EnergyCard } from \'../../game/store/card/energy-card\';');
  lines.push('import { CardType, EnergyType } from \'../../game/store/card/card-types\';');
  lines.push('import { StoreLike, State } from \'../../game\';');
  lines.push('import { Effect } from \'../../game/store/effects/effect\';');
  lines.push('');
  lines.push(`export class ${className} extends EnergyCard {`);

  lines.push('  public provides: CardType[] = [C];');
  lines.push('  public energyType = EnergyType.SPECIAL;');

  if (card.regulationMark) {
    lines.push(`  public regulationMark: string = '${card.regulationMark}';`);
  }
  lines.push(`  public set: string = '${setCode}';`);
  lines.push(`  public setNumber: string = '${card.number}';`);
  lines.push('  public cardImage: string = \'assets/cardback.png\';');
  lines.push(`  public name: string = '${escapeSingleQuotes(card.name)}';`);
  lines.push(`  public fullName: string = '${escapeSingleQuotes(fullName)}';`);

  const rules = card.rules || [];
  const meaningfulRules = filterGenericRules(rules).map(convertEnergyNames);
  if (meaningfulRules.length > 0) {
    const text = escapeSingleQuotes(meaningfulRules.join(' '));
    lines.push(`  public text: string = '${text}';`);
  }

  lines.push('');
  lines.push('  public reduceEffect(store: StoreLike, state: State, effect: Effect): State {');
  lines.push('    // TODO: Implement energy effect');
  if (meaningfulRules.length > 0) {
    for (const rule of meaningfulRules) {
      lines.push(`    // ${rule.replace(/\n/g, ' ')}`);
    }
  }
  lines.push('');
  lines.push('    return state;');
  lines.push('  }');

  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

// ==================== OTHER-PRINTS GENERATION ====================

interface OtherPrintEntry {
  className: string;
  sourceClassName: string;
  importPath: string;
  setCode: string;
  setNumber: string;
  fullName: string;
  importAlias?: string; // Set when aliasing is needed to avoid import collisions
}

function generateOtherPrintsEntry(entry: OtherPrintEntry): string {
  const extendsName = entry.importAlias || entry.sourceClassName;
  return [
    '',
    `export class ${entry.className} extends ${extendsName} {`,
    `  public set: string = '${entry.setCode}';`,
    `  public setNumber: string = '${entry.setNumber}';`,
    `  public fullName: string = '${escapeSingleQuotes(entry.fullName)}';`,
    '}',
    '',
  ].join('\n');
}

// ==================== INDEX GENERATION ====================

function generateIndex(
  setDir: string,
  setDirName: string,
  allCardFiles: { className: string; fileName: string; category: string }[],
  otherPrintClasses: string[]
): string {
  const setVarName = 'set' + setDirName
    .replace(/^set-/, '')
    .split('-')
    .map((w: string) => w.charAt(0).toUpperCase() + w.slice(1))
    .join('');

  const pokemon = allCardFiles.filter(c => c.category === 'pokemon');
  const trainers = allCardFiles.filter(c => c.category === 'trainer');
  const energy = allCardFiles.filter(c => c.category === 'energy');

  let content = 'import { Card } from \'../../game/store/card/card\';\n';

  for (const card of [...pokemon, ...trainers, ...energy]) {
    content += `import { ${card.className} } from './${card.fileName}';\n`;
  }

  if (otherPrintClasses.length > 0) {
    content += '\nimport {\n';
    content += otherPrintClasses.map(c => `  ${c},`).join('\n');
    content += '\n} from \'./other-prints\';\n';
  }

  content += `\nexport const ${setVarName}: Card[] = [\n`;

  if (pokemon.length > 0) {
    content += '  // Pokemon\n';
    for (const card of pokemon) {
      content += `  new ${card.className}(),\n`;
    }
    content += '\n';
  }

  if (trainers.length > 0) {
    content += '  // Trainers\n';
    for (const card of trainers) {
      content += `  new ${card.className}(),\n`;
    }
    content += '\n';
  }

  if (energy.length > 0) {
    content += '  // Energy\n';
    for (const card of energy) {
      content += `  new ${card.className}(),\n`;
    }
    content += '\n';
  }

  if (otherPrintClasses.length > 0) {
    content += '  // Other Prints (Reprints & Alt Arts)\n';
    for (const cls of otherPrintClasses) {
      content += `  new ${cls}(),\n`;
    }
  }

  content += '];\n';

  return content;
}

// ==================== MAIN ====================

function main() {
  const args = process.argv.slice(2);
  const setDirName = args.find(a => !a.startsWith('--'));
  const dryRun = args.includes('--dry-run');
  const force = args.includes('--force');

  if (!setDirName) {
    console.error('Usage: npx ts-node ptcg-server/src/sets/generate-set-stubs.ts <set-directory-name> [--dry-run] [--force]');
    process.exit(1);
  }

  const setsDir = path.resolve(__dirname);
  const setDir = path.join(setsDir, setDirName);
  const cardDataPath = path.join(setDir, 'card-data.json');

  if (!fs.existsSync(cardDataPath)) {
    console.error(`card-data.json not found at ${cardDataPath}`);
    process.exit(1);
  }

  const cards: any[] = JSON.parse(fs.readFileSync(cardDataPath, 'utf-8'));
  if (!cards.length) {
    console.error('No cards found in card-data.json');
    process.exit(1);
  }

  const setCode = cards[0].set?.ptcgoCode || '';
  if (!setCode) {
    console.error('Could not determine set code from card data');
    process.exit(1);
  }

  console.log(`\nProcessing ${cards.length} cards for ${setDirName} (${setCode})...`);
  if (dryRun) console.log('[DRY RUN - no files will be written]\n');

  // ---- Read existing state ----

  const otherPrintsPath = path.join(setDir, 'other-prints.ts');
  let existingOtherPrints = '';
  const existingOtherPrintClasses: string[] = [];
  const existingOtherPrintSetNumbers = new Set<string>();

  if (fs.existsSync(otherPrintsPath)) {
    existingOtherPrints = fs.readFileSync(otherPrintsPath, 'utf-8');
    for (const m of existingOtherPrints.matchAll(/export class (\w+)/g)) {
      existingOtherPrintClasses.push(m[1]);
    }
    for (const m of existingOtherPrints.matchAll(/setNumber\s*=\s*'([^']+)'/g)) {
      existingOtherPrintSetNumbers.add(m[1]);
    }
  }

  // Existing .ts files (card stubs)
  const existingFiles = new Set<string>();
  const existingClassNames = new Map<string, string>(); // fileName → className
  if (fs.existsSync(setDir)) {
    for (const f of fs.readdirSync(setDir)) {
      if (f.endsWith('.ts') && f !== 'index.ts' && f !== 'other-prints.ts') {
        const baseName = f.replace('.ts', '');
        existingFiles.add(baseName);
        // Read class name
        try {
          const content = fs.readFileSync(path.join(setDir, f), 'utf-8');
          const match = content.match(/export class (\w+)/);
          if (match) existingClassNames.set(baseName, match[1]);
        } catch { /* skip */ }
      }
    }
  }

  // ---- Build cross-set index ----
  console.log('Building cross-set card index...');
  const crossSetIndex = buildCrossSetIndex(setsDir, setDirName);

  // ---- Process cards ----

  // Sort cards by number to ensure consistent ordering
  const sortedCards = [...cards].sort((a, b) => {
    const numA = parseInt(a.number, 10) || 0;
    const numB = parseInt(b.number, 10) || 0;
    return numA - numB;
  });

  // Track name occurrences for duplicate class/file naming
  const nameCount = new Map<string, number>();

  interface CardAction {
    card: any;
    className: string;
    fileName: string;
    fullName: string;
    action: 'skip' | 'generate' | 'intra-reprint' | 'cross-reprint';
    needsReduceEffect: boolean;
    category: 'pokemon' | 'trainer' | 'energy';
    sourceClassName?: string;
    sourceImportPath?: string;
    nameOccurrence: number;
  }

  const cardActions: CardAction[] = [];

  // First pass: assign names
  for (const card of sortedCards) {
    const baseName = card.name;
    const count = (nameCount.get(baseName) || 0) + 1;
    nameCount.set(baseName, count);

    let className = toPascalCase(baseName);
    let fileName = toKebabCase(baseName);

    if (count > 1) {
      className += count.toString();
      fileName += `-${count}`;
    }

    const fullName = count > 1
      ? `${baseName} ${setCode} ${card.number}`
      : `${baseName} ${setCode}`;

    const category: 'pokemon' | 'trainer' | 'energy' =
      card.supertype === 'Pokémon' ? 'pokemon' :
        card.supertype === 'Trainer' ? 'trainer' : 'energy';

    cardActions.push({
      card,
      className,
      fileName,
      fullName,
      action: 'generate',
      needsReduceEffect: cardNeedsReduceEffect(card),
      category,
      nameOccurrence: count,
    });
  }

  // Second pass: determine actions
  // Build name → first occurrence index for intra-set reprint detection
  const nameToIndices = new Map<string, number[]>();
  for (let i = 0; i < cardActions.length; i++) {
    const name = cardActions[i].card.name;
    const list = nameToIndices.get(name) || [];
    list.push(i);
    nameToIndices.set(name, list);
  }

  for (let i = 0; i < cardActions.length; i++) {
    const ca = cardActions[i];
    const card = ca.card;

    // Skip basic energies
    if (card.supertype === 'Energy' && card.subtypes?.includes('Basic')) {
      ca.action = 'skip';
      continue;
    }

    // Skip if file already exists (unless --force)
    if (existingFiles.has(ca.fileName) && !force) {
      ca.action = 'skip';
      continue;
    }

    // Skip if already in other-prints.ts
    if (existingOtherPrintSetNumbers.has(card.number)) {
      ca.action = 'skip';
      continue;
    }

    // Check for intra-set reprint (compare against earlier cards with same name)
    const sameNameIndices = nameToIndices.get(card.name) || [];
    let isIntraReprint = false;
    for (const earlierIdx of sameNameIndices) {
      if (earlierIdx >= i) break;
      const earlierCA = cardActions[earlierIdx];
      if (earlierCA.action === 'skip' && !existingFiles.has(earlierCA.fileName)) continue;

      if (cardsAreIdentical(earlierCA.card, card)) {
        ca.action = 'intra-reprint';

        // Determine source class
        if (existingFiles.has(earlierCA.fileName)) {
          ca.sourceClassName = existingClassNames.get(earlierCA.fileName) || earlierCA.className;
          ca.sourceImportPath = `./${earlierCA.fileName}`;
        } else if (earlierCA.action === 'cross-reprint' && earlierCA.sourceClassName) {
          ca.sourceClassName = earlierCA.sourceClassName;
          ca.sourceImportPath = earlierCA.sourceImportPath;
        } else {
          ca.sourceClassName = earlierCA.className;
          ca.sourceImportPath = `./${earlierCA.fileName}`;
        }
        isIntraReprint = true;
        break;
      }
    }
    if (isIntraReprint) continue;

    // Check for cross-set reprint (must match name + attack names + ability names)
    const crossEntries = crossSetIndex.get(card.name);
    if (crossEntries) {
      const cardAttackNames = (card.attacks || []).map((a: any) => a.name);
      const cardAbilityNames = (card.abilities || []).map((a: any) => a.name);
      const source = crossEntries.find(e => {
        if (!e.hasReduceEffect) return false;
        // Compare attack names
        if (e.attackNames.length !== cardAttackNames.length) return false;
        for (let j = 0; j < cardAttackNames.length; j++) {
          if (e.attackNames[j] !== cardAttackNames[j]) return false;
        }
        // Compare ability names
        if (e.abilityNames.length !== cardAbilityNames.length) return false;
        for (let j = 0; j < cardAbilityNames.length; j++) {
          if (e.abilityNames[j] !== cardAbilityNames[j]) return false;
        }
        return true;
      });
      if (source) {
        ca.action = 'cross-reprint';
        ca.sourceClassName = source.className;
        ca.sourceImportPath = `../${source.setDir}/${source.fileName}`;
        continue;
      }
    }

    // Default: generate stub
    ca.action = 'generate';
  }

  // ---- Generate files ----

  let generatedCount = 0;
  let vanillaCount = 0;
  let effectPokemonCount = 0;
  let trainerCount = 0;
  let energyCount = 0;
  let reprintCount = 0;
  let skippedCount = 0;

  const newOtherPrints: OtherPrintEntry[] = [];

  // Track all card files for index generation (fileName → {className, category})
  const allCardFileMap = new Map<string, { className: string; category: string }>();

  // Register existing files
  for (const [fileName, className] of existingClassNames) {
    // Determine category from file content
    let cat = 'pokemon';
    try {
      const content = fs.readFileSync(path.join(setDir, fileName + '.ts'), 'utf-8');
      if (content.match(/extends\s+TrainerCard/)) cat = 'trainer';
      else if (content.match(/extends\s+EnergyCard/)) cat = 'energy';
    } catch { /* skip */ }
    allCardFileMap.set(fileName, { className, category: cat });
  }

  for (const ca of cardActions) {
    if (ca.action === 'skip') {
      skippedCount++;
      continue;
    }

    if (ca.action === 'intra-reprint' || ca.action === 'cross-reprint') {
      reprintCount++;

      let reprintClassName: string;
      let reprintFullName: string;

      if (ca.action === 'intra-reprint') {
        reprintClassName = ca.className;
        reprintFullName = `${ca.card.name} ${setCode} ${ca.card.number}`;
      } else {
        reprintClassName = toPascalCase(ca.card.name) + setCode;
        // Avoid collision
        if (existingOtherPrintClasses.includes(reprintClassName) ||
            newOtherPrints.some(e => e.className === reprintClassName)) {
          reprintClassName += ca.card.number;
        }
        reprintFullName = `${ca.card.name} ${setCode}`;
        // Check if another cross-set reprint for same card already exists
        if (newOtherPrints.some(e => e.fullName === reprintFullName)) {
          reprintFullName = `${ca.card.name} ${setCode} ${ca.card.number}`;
        }
      }

      newOtherPrints.push({
        className: reprintClassName,
        sourceClassName: ca.sourceClassName!,
        importPath: ca.sourceImportPath!,
        setCode,
        setNumber: ca.card.number,
        fullName: reprintFullName,
      });

      continue;
    }

    // Generate stub file
    let content: string;
    if (ca.category === 'pokemon') {
      content = generatePokemonStub(ca.card, ca.className, setCode, ca.needsReduceEffect, ca.fullName);
      if (ca.needsReduceEffect) {
        effectPokemonCount++;
      } else {
        vanillaCount++;
      }
    } else if (ca.category === 'trainer') {
      content = generateTrainerStub(ca.card, ca.className, setCode, ca.fullName);
      trainerCount++;
    } else {
      content = generateEnergyStub(ca.card, ca.className, setCode, ca.fullName);
      energyCount++;
    }

    const filePath = path.join(setDir, ca.fileName + '.ts');

    if (dryRun) {
      console.log(`  [DRY RUN] Would create: ${ca.fileName}.ts (${ca.className})`);
    } else {
      fs.writeFileSync(filePath, content, 'utf-8');
      console.log(`  Created: ${ca.fileName}.ts (${ca.className})`);
    }

    allCardFileMap.set(ca.fileName, { className: ca.className, category: ca.category });
    generatedCount++;
  }

  // ---- Update other-prints.ts ----

  if (newOtherPrints.length > 0) {
    // Resolve import aliases: track className → importPath to detect collisions
    const classNameToPath = new Map<string, string>();
    // Seed with existing imports from other-prints.ts
    if (existingOtherPrints) {
      for (const m of existingOtherPrints.matchAll(/import\s*\{\s*(\w+)(?:\s+as\s+\w+)?\s*\}\s*from\s*'([^']+)'/g)) {
        classNameToPath.set(m[1], m[2]);
      }
    }
    for (const entry of newOtherPrints) {
      const existingPath = classNameToPath.get(entry.sourceClassName);
      if (existingPath && existingPath !== entry.importPath) {
        // Collision: same class name, different path → need alias
        const setDirPart = entry.importPath.match(/set-([^/]+)/);
        const suffix = setDirPart ? setDirPart[1].split('-').map((w: string) => w.charAt(0).toUpperCase() + w.slice(1)).join('') : entry.setNumber;
        entry.importAlias = entry.sourceClassName + suffix;
      } else {
        classNameToPath.set(entry.sourceClassName, entry.importPath);
      }
    }

    // Collect unique imports (className or alias → importPath)
    interface ImportInfo { className: string; alias?: string; importPath: string; }
    const imports: ImportInfo[] = [];
    const seenImports = new Set<string>();
    for (const entry of newOtherPrints) {
      const key = `${entry.sourceClassName}|${entry.importPath}`;
      if (seenImports.has(key)) continue;
      seenImports.add(key);
      imports.push({ className: entry.sourceClassName, alias: entry.importAlias, importPath: entry.importPath });
    }

    if (dryRun) {
      console.log(`\n  [DRY RUN] Would add ${newOtherPrints.length} entries to other-prints.ts:`);
      for (const entry of newOtherPrints) {
        console.log(`    ${entry.className} extends ${entry.importAlias || entry.sourceClassName}`);
      }
    } else {
      let otherPrintsContent = existingOtherPrints;

      if (!otherPrintsContent) {
        // Create new other-prints.ts
        const importLines: string[] = [];
        for (const imp of imports) {
          if (imp.alias) {
            importLines.push(`import { ${imp.className} as ${imp.alias} } from '${imp.importPath}';`);
          } else {
            importLines.push(`import { ${imp.className} } from '${imp.importPath}';`);
          }
        }
        const classLines = newOtherPrints.map(e => generateOtherPrintsEntry(e));
        otherPrintsContent = importLines.join('\n') + '\n' + classLines.join('');
      } else {
        // Append to existing
        const newImportLines: string[] = [];
        for (const imp of imports) {
          // Check if this specific class is already imported from this path
          const alreadyImported = otherPrintsContent.includes(`} from '${imp.importPath}'`);
          if (!alreadyImported) {
            if (imp.alias) {
              newImportLines.push(`import { ${imp.className} as ${imp.alias} } from '${imp.importPath}';`);
            } else {
              newImportLines.push(`import { ${imp.className} } from '${imp.importPath}';`);
            }
          }
        }

        if (newImportLines.length > 0) {
          const lines = otherPrintsContent.split('\n');
          let lastImportIdx = -1;
          for (let i = 0; i < lines.length; i++) {
            if (lines[i].startsWith('import ')) lastImportIdx = i;
          }
          if (lastImportIdx >= 0) {
            lines.splice(lastImportIdx + 1, 0, ...newImportLines);
            otherPrintsContent = lines.join('\n');
          } else {
            otherPrintsContent = newImportLines.join('\n') + '\n' + otherPrintsContent;
          }
        }

        // Append new class definitions
        const classLines = newOtherPrints.map(e => generateOtherPrintsEntry(e));
        otherPrintsContent = otherPrintsContent.trimEnd() + '\n' + classLines.join('');
      }

      fs.writeFileSync(otherPrintsPath, otherPrintsContent, 'utf-8');
      console.log(`\n  Updated other-prints.ts with ${newOtherPrints.length} new entries`);
    }
  }

  // ---- Generate index.ts ----

  // Include newly generated files in allCardFileMap (already done above)
  // Also scan for any files we haven't tracked (e.g., existing files that weren't in cardActions)
  if (fs.existsSync(setDir)) {
    for (const f of fs.readdirSync(setDir)) {
      if (f.endsWith('.ts') && f !== 'index.ts' && f !== 'other-prints.ts') {
        const baseName = f.replace('.ts', '');
        if (!allCardFileMap.has(baseName)) {
          try {
            const content = fs.readFileSync(path.join(setDir, f), 'utf-8');
            const match = content.match(/export class (\w+)/);
            if (match) {
              let cat = 'pokemon';
              if (content.match(/extends\s+TrainerCard/)) cat = 'trainer';
              else if (content.match(/extends\s+EnergyCard/)) cat = 'energy';
              allCardFileMap.set(baseName, { className: match[1], category: cat });
            }
          } catch { /* skip */ }
        }
      }
    }
  }

  // Sort card files alphabetically
  const sortedCardFiles = [...allCardFileMap.entries()]
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([fileName, info]) => ({ className: info.className, fileName, category: info.category }));

  // Collect all other-prints class names
  const allOtherPrintClasses = [
    ...existingOtherPrintClasses,
    ...newOtherPrints.map(e => e.className).filter(c => !existingOtherPrintClasses.includes(c)),
  ];

  const indexContent = generateIndex(setDir, setDirName, sortedCardFiles, allOtherPrintClasses);
  const indexPath = path.join(setDir, 'index.ts');

  if (dryRun) {
    console.log('\n  [DRY RUN] Would update index.ts');
  } else {
    fs.writeFileSync(indexPath, indexContent, 'utf-8');
    console.log('  Updated index.ts');
  }

  // ---- Summary ----

  console.log('\n========================================');
  console.log(`Generated ${generatedCount} card stubs for ${setDirName} (${setCode})`);
  console.log(`  ${vanillaCount} vanilla cards (no reduceEffect needed, ready to use)`);
  console.log(`  ${effectPokemonCount} Pokemon with attack/ability effects (TODO)`);
  console.log(`  ${trainerCount} Trainers with effects (TODO)`);
  if (energyCount > 0) console.log(`  ${energyCount} Special Energy cards (TODO)`);
  console.log(`  ${reprintCount} reprints (other-prints.ts, ready to use)`);
  console.log(`  ${skippedCount} cards skipped (already exist)`);
  console.log('========================================\n');
}

main();
