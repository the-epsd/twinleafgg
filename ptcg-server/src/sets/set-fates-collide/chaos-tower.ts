// This file was auto-generated by the card stub generator.
// Card effects were implemented by an agent.
// If you have any questions or feedback, reach out to @C4 in the discord.

import { TrainerCard } from '../../game/store/card/trainer-card';
import { SpecialCondition, TrainerType } from '../../game/store/card/card-types';
import { PlayerType, StoreLike, State, StateUtils } from '../../game';
import { Effect } from '../../game/store/effects/effect';
import { AddSpecialConditionsEffect } from '../../game/store/effects/attack-effects';
import { AddSpecialConditionsPowerEffect, CheckTableStateEffect } from '../../game/store/effects/check-effects';
import { PlayStadiumEffect } from '../../game/store/effects/play-card-effects';
import { SELECT_PROMPT } from '../../game/store/prefabs/prefabs';

export class ChaosTower extends TrainerCard {
  public trainerType: TrainerType = TrainerType.STADIUM;
  public set: string = 'FCO';
  public setNumber: string = '94';
  public cardImage: string = 'assets/cardback.png';
  public name: string = 'Chaos Tower';
  public fullName: string = 'Chaos Tower FCO';
  public text: string = 'Choose which way this card faces before you play it. This \u2193 player\'s Pok\u00e9mon can\'t be Confused or Poisoned. (If those Pok\u00e9mon are already Confused or Poisoned, remove those Special Conditions.) Choose which way this card faces before you play it. This \u2193 player\'s Pok\u00e9mon can\'t be Asleep or Paralyzed. (If those Pok\u00e9mon are already Asleep or Paralyzed, remove those Special Conditions.)';

  // orientation: 0 = player gets Confused/Poison immunity, opponent gets Asleep/Paralyzed immunity
  //              1 = player gets Asleep/Paralyzed immunity, opponent gets Confused/Poison immunity
  public readonly CHAOS_TOWER_CHOICE_MARKER = 'CHAOS_TOWER_FCO_CHOICE';
  public readonly CHAOS_TOWER_CHOICE_B_MARKER = 'CHAOS_TOWER_FCO_CHOICE_B';

  // Ref: set-furious-fists/sparkling-robe.ts (PREVENT_AND_CLEAR_SPECIAL_CONDITIONS pattern adapted for stadium)
  public reduceEffect(store: StoreLike, state: State, effect: Effect): State {
    // When the stadium is played, prompt for orientation choice
    if (effect instanceof PlayStadiumEffect && effect.trainerCard === this) {
      const player = effect.player;
      const opponent = StateUtils.getOpponent(state, player);

      SELECT_PROMPT(store, state, player,
        ['Confused/Poisoned immunity for you', 'Asleep/Paralyzed immunity for you'],
        choice => {
          if (choice === 0) {
            // Player gets Confused/Poison immunity, Opponent gets Asleep/Paralyzed immunity
            player.marker.addMarker(this.CHAOS_TOWER_CHOICE_MARKER, this);
            opponent.marker.addMarker(this.CHAOS_TOWER_CHOICE_B_MARKER, this);
          } else {
            // Player gets Asleep/Paralyzed immunity, Opponent gets Confused/Poison immunity
            player.marker.addMarker(this.CHAOS_TOWER_CHOICE_B_MARKER, this);
            opponent.marker.addMarker(this.CHAOS_TOWER_CHOICE_MARKER, this);
          }

          // Clear existing conditions based on choice
          this.clearBlockedConditions(state);
        }
      );
    }

    // Prevent blocked special conditions from being applied
    if (effect instanceof AddSpecialConditionsEffect || effect instanceof AddSpecialConditionsPowerEffect) {
      const stadiumCard = StateUtils.getStadiumCard(state);
      if (stadiumCard !== this) {
        return state;
      }

      const targetOwner = StateUtils.findOwner(state, effect.target);

      if (targetOwner.marker.hasMarker(this.CHAOS_TOWER_CHOICE_MARKER, this)) {
        // This player has Confused/Poisoned immunity
        effect.specialConditions = effect.specialConditions.filter(
          sc => sc !== SpecialCondition.CONFUSED && sc !== SpecialCondition.POISONED
        );
        if (effect.specialConditions.length === 0) {
          effect.preventDefault = true;
        }
      } else if (targetOwner.marker.hasMarker(this.CHAOS_TOWER_CHOICE_B_MARKER, this)) {
        // This player has Asleep/Paralyzed immunity
        effect.specialConditions = effect.specialConditions.filter(
          sc => sc !== SpecialCondition.ASLEEP && sc !== SpecialCondition.PARALYZED
        );
        if (effect.specialConditions.length === 0) {
          effect.preventDefault = true;
        }
      }
    }

    // Clear existing blocked conditions during CheckTableState
    if (effect instanceof CheckTableStateEffect) {
      const stadiumCard = StateUtils.getStadiumCard(state);
      if (stadiumCard !== this) {
        return state;
      }
      this.clearBlockedConditions(state);
    }

    return state;
  }

  private clearBlockedConditions(state: State): void {
    state.players.forEach(player => {
      if (player.marker.hasMarker(this.CHAOS_TOWER_CHOICE_MARKER, this)) {
        // Player has Confused/Poisoned immunity
        player.forEachPokemon(PlayerType.BOTTOM_PLAYER, cardList => {
          cardList.removeSpecialCondition(SpecialCondition.CONFUSED);
          cardList.removeSpecialCondition(SpecialCondition.POISONED);
        });
      } else if (player.marker.hasMarker(this.CHAOS_TOWER_CHOICE_B_MARKER, this)) {
        // Player has Asleep/Paralyzed immunity
        player.forEachPokemon(PlayerType.BOTTOM_PLAYER, cardList => {
          cardList.removeSpecialCondition(SpecialCondition.ASLEEP);
          cardList.removeSpecialCondition(SpecialCondition.PARALYZED);
        });
      }
    });
  }
}
