// This file was auto-generated by the card stub generator.
// Card effects were implemented by an agent.
// If you have any questions or feedback, reach out to @C4 in the discord.

import { PokemonCard } from '../../game/store/card/pokemon-card';
import { Stage, CardType, CardTag } from '../../game/store/card/card-types';
import { PowerType, StoreLike, State, StateUtils, GameMessage } from '../../game';
import { Effect } from '../../game/store/effects/effect';
import { DrawPrizesEffect } from '../../game/store/effects/game-effects';
import { EndTurnEffect } from '../../game/store/effects/game-phase-effects';
import { ADD_SLEEP_TO_PLAYER_ACTIVE, AFTER_ATTACK, CONFIRMATION_PROMPT, GET_PLAYER_BENCH_SLOTS, IS_ABILITY_BLOCKED, TAKE_SPECIFIC_PRIZES, TAKE_X_PRIZES, WAS_ATTACK_USED } from '../../game/store/prefabs/prefabs';

export class Jirachi extends PokemonCard {
  public tags = [CardTag.PRISM_STAR];
  public stage: Stage = Stage.BASIC;
  public cardType: CardType = M;
  public hp: number = 80;
  public weakness = [{ type: R }];
  public resistance = [{ type: P, value: -20 }];
  public retreat = [C];

  public powers = [{
    name: 'Wish Upon a Star',
    powerType: PowerType.ABILITY,
    exemptFromAbilityLock: true,
    text: 'If you took this Pokémon as a face-down Prize card during your turn and your Bench isn\'t full, before you put it into your hand, you may put it onto your Bench and take 1 more Prize card.'
  }];

  public attacks = [
    {
      name: 'Perish Dream',
      cost: [C, C, C],
      damage: 10,
      text: 'This Pokémon is now Asleep. At the end of your opponent\'s next turn, the Defending Pokémon will be Knocked Out.'
    }
  ];

  public set: string = 'CES';
  public setNumber: string = '97';
  public cardImage: string = 'assets/cardback.png';
  public name: string = 'Jirachi \u25c7';
  public fullName: string = 'Jirachi \u25c7 CES';

  public readonly KNOCKOUT_MARKER = 'JIRACHI_CES_KNOCKOUT_MARKER';
  public readonly CLEAR_KNOCKOUT_MARKER = 'JIRACHI_CES_CLEAR_KNOCKOUT_MARKER';

  public abilityUsed = false;

  public reduceEffect(store: StoreLike, state: State, effect: Effect): State {
    // Ability: Wish Upon a Star
    // Ref: set-celestial-storm/jirachi-prism-star.ts (Wish Upon a Star)
    if (effect instanceof DrawPrizesEffect) {
      const generator = this.handlePrizeEffect(
        () => generator.next(),
        store,
        state,
        effect
      );
      return generator.next().value;
    }

    // Attack: Perish Dream
    // Ref: set-celestial-storm/jirachi-prism-star.ts (Perish Dream)
    if (WAS_ATTACK_USED(effect, 0, this)) {
      const player = effect.player;
      const opponent = StateUtils.getOpponent(state, player);

      // Add delayed KO marker to defending Pokemon
      player.marker.addMarker(this.KNOCKOUT_MARKER, this);
      opponent.active.marker.addMarker(this.CLEAR_KNOCKOUT_MARKER, this);
    }

    // Ref: set-celestial-storm/jirachi-prism-star.ts (Perish Dream - self Asleep after attack)
    if (AFTER_ATTACK(effect, 0, this)) {
      ADD_SLEEP_TO_PLAYER_ACTIVE(store, state, effect.player, this);
    }

    // Delayed KO at end of opponent's next turn
    if (effect instanceof EndTurnEffect && effect.player.active.marker.hasMarker(this.CLEAR_KNOCKOUT_MARKER, this)) {
      const player = effect.player;
      const opponent = StateUtils.getOpponent(state, player);

      effect.player.active.damage = 999;
      effect.player.active.marker.removeMarker(this.CLEAR_KNOCKOUT_MARKER, this);
      opponent.marker.removeMarker(this.KNOCKOUT_MARKER, this);
    }

    return state;
  }

  private *handlePrizeEffect(next: Function, store: StoreLike, state: State, effect: DrawPrizesEffect): IterableIterator<State> {
    const player = effect.player;
    const prizeCard = effect.prizes.find(cardList => cardList.cards.includes(this));

    // Check if ability conditions are met
    if (!prizeCard || GET_PLAYER_BENCH_SLOTS(player).length === 0 || !prizeCard.isSecret || effect.destination !== player.hand) {
      return state;
    }

    // Prevent unintended multiple uses
    if (this.abilityUsed) {
      return state;
    }
    this.abilityUsed = true;

    // Check if ability is blocked
    if (IS_ABILITY_BLOCKED(store, state, player, this)) {
      return state;
    }

    // Prevent prize card from going to hand until we complete the ability flow
    effect.preventDefault = true;

    // Ask player if they want to use the ability
    let wantToUse = false;
    yield CONFIRMATION_PROMPT(store, state, player, result => {
      wantToUse = result;
      next();
    }, GameMessage.WANT_TO_USE_ABILITY_FROM_PRIZES);

    // If the player declines, move the original prize card to hand
    const prizeIndex = player.prizes.findIndex(prize => prize.cards.includes(this));
    const fallback: (prizeIndex: number) => void = (prizeIndex) => {
      if (prizeIndex !== -1) {
        TAKE_SPECIFIC_PRIZES(store, state, player, [player.prizes[prizeIndex]], { skipReduce: true });
      }
      return;
    };

    if (!wantToUse) {
      effect.preventDefault = false;
      fallback(prizeIndex);
      return state;
    }

    // Check bench slots again (may have changed during generator flow)
    const emptyBenchSlots = GET_PLAYER_BENCH_SLOTS(player);

    if (emptyBenchSlots.length === 0) {
      effect.preventDefault = false;
      fallback(prizeIndex);
      return state;
    }

    // Move this card to bench (counts as a prize taken)
    this.abilityUsed = true;
    player.prizesTaken += 1;

    const targetSlot = emptyBenchSlots[0];
    for (const [index, prize] of player.prizes.entries()) {
      if (prize.cards.includes(this)) {
        player.prizes[index].moveTo(targetSlot);
        targetSlot.pokemonPlayedTurn = state.turn;
        break;
      }
    }

    // Handle extra prize (excluding the group this card is in)
    yield TAKE_X_PRIZES(store, state, player, 1, {
      promptOptions: {
        blocked: effect.prizes.map(p => player.prizes.indexOf(p))
      }
    }, () => next());

    return state;
  }
}
