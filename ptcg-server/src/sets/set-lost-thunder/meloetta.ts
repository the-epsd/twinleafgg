// This file was auto-generated by the card stub generator.
// Card effects were implemented by an agent.
// If you have any questions or feedback, reach out to @C4 in the discord.

import { PokemonCard } from '../../game/store/card/pokemon-card';
import { Stage, CardType } from '../../game/store/card/card-types';
import { StoreLike, State, StateUtils, PlayerType } from '../../game';
import { Effect } from '../../game/store/effects/effect';
import { DealDamageEffect, PutDamageEffect } from '../../game/store/effects/attack-effects';
import { WAS_ATTACK_USED, MULTIPLE_COIN_FLIPS_PROMPT } from '../../game/store/prefabs/prefabs';
import { YOUR_OPPPONENTS_ACTIVE_POKEMON_IS_NOW_ASLEEP } from '../../game/store/prefabs/attack-effects';

export class Meloetta extends PokemonCard {
  public stage: Stage = Stage.BASIC;
  public cardType: CardType = P;
  public hp: number = 80;
  public weakness = [{ type: P }];
  public retreat = [C];

  public attacks = [
    {
      name: 'Sing',
      cost: [C],
      damage: 0,
      text: 'Your opponent\'s Active Pokémon is now Asleep.'
    },
    {
      name: 'Miracle Harmony',
      cost: [P, C, C],
      damage: 0,
      text: 'Flip a coin for each of your Pokémon in play that has the Sing attack. This attack does 10 damage for each heads to each of your opponent\'s Pokémon. (Don\'t apply Weakness and Resistance for Benched Pokémon.)'
    }
  ];

  public set: string = 'LOT';
  public setNumber: string = '104';
  public cardImage: string = 'assets/cardback.png';
  public name: string = 'Meloetta';
  public fullName: string = 'Meloetta LOT';

  public reduceEffect(store: StoreLike, state: State, effect: Effect): State {
    // Attack 1: Sing
    // Ref: set-celestial-storm/deoxys-2.ts (status condition)
    if (WAS_ATTACK_USED(effect, 0, this)) {
      YOUR_OPPPONENTS_ACTIVE_POKEMON_IS_NOW_ASLEEP(store, state, effect);
    }

    // Attack 2: Miracle Harmony
    // Refs: AGENTS-patterns.md (multiple coin flips), set-steam-siege/bastiodon.ts (bench damage)
    if (WAS_ATTACK_USED(effect, 1, this)) {
      const player = effect.player;
      const opponent = StateUtils.getOpponent(state, player);

      let singCount = 0;
      player.forEachPokemon(PlayerType.BOTTOM_PLAYER, (cardList, card) => {
        if (card.attacks && card.attacks.some(a => a.name === 'Sing')) {
          singCount++;
        }
      });

      if (singCount > 0) {
        MULTIPLE_COIN_FLIPS_PROMPT(store, state, player, singCount, results => {
          const heads = results.filter(r => r).length;
          if (heads > 0) {
            const totalDamage = 10 * heads;

            // DealDamageEffect for active (applies W/R)
            const activeDamage = new DealDamageEffect(effect, totalDamage);
            activeDamage.target = opponent.active;
            store.reduceEffect(state, activeDamage);

            // PutDamageEffect for bench (no W/R)
            opponent.bench.forEach(benched => {
              if (benched.cards.length > 0) {
                const benchDamage = new PutDamageEffect(effect, totalDamage);
                benchDamage.target = benched;
                store.reduceEffect(state, benchDamage);
              }
            });
          }
        });
      }
    }

    return state;
  }
}
